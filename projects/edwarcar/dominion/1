/*********************** Randomly Testing Village Card **************************/
Iteration 0: test passed 
Iteration 1: test passed 
Iteration 2: test passed 
Iteration 3: test passed 
Iteration 4: test passed 
Iteration 5: test passed 
Iteration 6: test passed 
Iteration 7: test passed 
Iteration 8: test passed 
Iteration 9: test passed 
Iteration 10: test passed 
Iteration 11: test passed 
Iteration 12: test passed 
Iteration 13: test passed 
Iteration 14: test passed 
Iteration 15: test passed 
Iteration 16: test passed 
Iteration 17: test passed 
Iteration 18: test passed 
Iteration 19: test passed 
Iteration 20: test passed 
Iteration 21: test passed 
Iteration 22: test passed 
Iteration 23: test passed 
Iteration 24: test passed 
Iteration 25: test passed 
Iteration 26: test passed 
Iteration 27: test passed 
Iteration 28: test passed 
Iteration 29: test passed 
Iteration 30: test passed 
Iteration 31: test passed 
Iteration 32: test passed 
Iteration 33: test passed 
Iteration 34: test passed 
Iteration 35: test passed 
Iteration 36: test passed 
Iteration 37: test passed 
Iteration 38: test passed 
Iteration 39: test passed 
Iteration 40: test passed 
Iteration 41: test passed 
Iteration 42: test passed 
Iteration 43: test passed 
Iteration 44: test passed 
Iteration 45: test passed 
Iteration 46: test passed 
Iteration 47: test passed 
Iteration 48: test passed 
Iteration 49: test passed 
Iteration 50: test passed 
Iteration 51: test passed 
Iteration 52: test passed 
Iteration 53: test passed 
Iteration 54: test passed 
Iteration 55: test passed 
Iteration 56: test passed 
Iteration 57: test passed 
Iteration 58: test passed 
Iteration 59: test passed 
Iteration 60: test passed 
Iteration 61: test passed 
Iteration 62: test passed 
Iteration 63: test passed 
Iteration 64: test passed 
Iteration 65: test passed 
Iteration 66: test passed 
Iteration 67: test passed 
Iteration 68: test passed 
Iteration 69: test passed 
Iteration 70: test passed 
Iteration 71: test passed 
Iteration 72: test passed 
Iteration 73: test passed 
Iteration 74: test passed 
Iteration 75: test passed 
Iteration 76: test passed 
Iteration 77: test passed 
Iteration 78: test passed 
Iteration 79: test passed 
Iteration 80: test passed 
Iteration 81: test passed 
Iteration 82: test passed 
Iteration 83: test passed 
Iteration 84: test passed 
Iteration 85: test passed 
Iteration 86: test passed 
Iteration 87: test passed 
Iteration 88: test passed 
Iteration 89: test passed 
Iteration 90: test passed 
Iteration 91: test passed 
Iteration 92: test passed 
Iteration 93: test passed 
Iteration 94: test passed 
Iteration 95: test passed 
Iteration 96: test passed 
Iteration 97: test passed 
Iteration 98: test passed 
Iteration 99: test passed 
Iteration 100: test passed 
Iteration 101: test passed 
Iteration 102: test passed 
Iteration 103: test passed 
Iteration 104: test passed 
Iteration 105: test passed 
Iteration 106: test passed 
Iteration 107: test passed 
Iteration 108: test passed 
Iteration 109: test passed 
Iteration 110: test passed 
Iteration 111: test passed 
Iteration 112: test passed 
Iteration 113: test passed 
Iteration 114: test passed 
Iteration 115: test passed 
Iteration 116: test passed 
Iteration 117: test passed 
Iteration 118: test passed 
Iteration 119: test passed 
Iteration 120: test passed 
Iteration 121: test passed 
Iteration 122: test passed 
Iteration 123: test passed 
Iteration 124: test passed 
Iteration 125: test passed 
Iteration 126: test passed 
Iteration 127: test passed 
Iteration 128: test passed 
Iteration 129: test passed 
Iteration 130: test passed 
Iteration 131: test passed 
Iteration 132: test passed 
Iteration 133: test passed 
Iteration 134: test passed 
Iteration 135: test passed 
Iteration 136: test passed 
Iteration 137: test passed 
Iteration 138: test passed 
Iteration 139: test passed 
Iteration 140: test passed 
Iteration 141: test passed 
Iteration 142: test passed 
Iteration 143: test passed 
Iteration 144: test passed 
Iteration 145: test passed 
Iteration 146: test passed 
Iteration 147: test passed 
Iteration 148: test passed 
Iteration 149: test passed 
Iteration 150: test passed 
Iteration 151: test passed 
Iteration 152: test passed 
Iteration 153: test passed 
Iteration 154: test passed 
Iteration 155: test passed 
Iteration 156: test passed 
Iteration 157: test passed 
Iteration 158: test passed 
Iteration 159: test passed 
Iteration 160: test passed 
Iteration 161: test passed 
Iteration 162: test passed 
Iteration 163: test passed 
Iteration 164: test passed 
Iteration 165: test passed 
Iteration 166: test passed 
Iteration 167: test passed 
Iteration 168: test passed 
Iteration 169: test passed 
Iteration 170: test passed 
Iteration 171: test passed 
Iteration 172: test passed 
Iteration 173: test passed 
Iteration 174: test passed 
Iteration 175: test passed 
Iteration 176: test passed 
Iteration 177: test passed 
Iteration 178: test passed 
Iteration 179: test passed 
Iteration 180: test passed 
Iteration 181: test passed 
Iteration 182: test passed 
Iteration 183: test passed 
Iteration 184: test passed 
Iteration 185: test passed 
Iteration 186: test passed 
Iteration 187: test passed 
Iteration 188: test passed 
Iteration 189: test passed 
Iteration 190: test passed 
Iteration 191: test passed 
Iteration 192: test passed 
Iteration 193: test passed 
Iteration 194: test passed 
Iteration 195: test passed 
Iteration 196: test passed 
Iteration 197: test passed 
Iteration 198: test passed 
Iteration 199: test passed 
Iteration 200: test passed 
Iteration 201: test passed 
Iteration 202: test passed 
Iteration 203: test passed 
Iteration 204: test passed 
Iteration 205: test passed 
Iteration 206: test passed 
Iteration 207: test passed 
Iteration 208: test passed 
Iteration 209: test passed 
Iteration 210: test passed 
Iteration 211: test passed 
Iteration 212: test passed 
Iteration 213: test passed 
Iteration 214: test passed 
Iteration 215: test passed 
Iteration 216: test passed 
Iteration 217: test passed 
Iteration 218: test passed 
Iteration 219: test passed 
Iteration 220: test passed 
Iteration 221: test passed 
Iteration 222: test passed 
Iteration 223: test passed 
Iteration 224: test passed 
Iteration 225: test passed 
Iteration 226: test passed 
Iteration 227: test passed 
Iteration 228: test passed 
Iteration 229: test passed 
Iteration 230: test passed 
Iteration 231: test passed 
Iteration 232: test passed 
Iteration 233: test passed 
Iteration 234: test passed 
Iteration 235: test passed 
Iteration 236: test passed 
Iteration 237: test passed 
Iteration 238: test passed 
Iteration 239: test passed 
Iteration 240: test passed 
Iteration 241: test passed 
Iteration 242: test passed 
Iteration 243: test passed 
Iteration 244: test passed 
Iteration 245: test passed 
Iteration 246: test passed 
Iteration 247: test passed 
Iteration 248: test passed 
Iteration 249: test passed 
Iteration 250: test passed 
Iteration 251: test passed 
Iteration 252: test passed 
Iteration 253: test passed 
Iteration 254: test passed 
Iteration 255: test passed 
Iteration 256: test passed 
Iteration 257: test passed 
Iteration 258: test passed 
Iteration 259: test passed 
Iteration 260: test passed 
Iteration 261: test passed 
Iteration 262: test passed 
Iteration 263: test passed 
Iteration 264: test passed 
Iteration 265: test passed 
Iteration 266: test passed 
Iteration 267: test passed 
Iteration 268: test passed 
Iteration 269: test passed 
Iteration 270: test passed 
Iteration 271: test passed 
Iteration 272: test passed 
Iteration 273: test passed 
Iteration 274: test passed 
Iteration 275: test passed 
Iteration 276: test passed 
Iteration 277: test passed 
Iteration 278: test passed 
Iteration 279: test passed 
Iteration 280: test passed 
Iteration 281: test passed 
Iteration 282: test passed 
Iteration 283: test passed 
Iteration 284: test passed 
Iteration 285: test passed 
Iteration 286: test passed 
Iteration 287: test passed 
Iteration 288: test passed 
Iteration 289: test passed 
Iteration 290: test passed 
Iteration 291: test passed 
Iteration 292: test passed 
Iteration 293: test passed 
Iteration 294: test passed 
Iteration 295: test passed 
Iteration 296: test passed 
Iteration 297: test passed 
Iteration 298: test passed 
Iteration 299: test passed 
Iteration 300: test passed 
Iteration 301: test passed 
Iteration 302: test passed 
Iteration 303: test passed 
Iteration 304: test passed 
Iteration 305: test passed 
Iteration 306: test passed 
Iteration 307: test passed 
Iteration 308: test passed 
Iteration 309: test passed 
Iteration 310: test passed 
Iteration 311: test passed 
Iteration 312: test passed 
Iteration 313: test passed 
Iteration 314: test passed 
Iteration 315: test passed 
Iteration 316: test passed 
Iteration 317: test passed 
Iteration 318: test passed 
Iteration 319: test passed 
Iteration 320: test passed 
Iteration 321: test passed 
Iteration 322: test passed 
Iteration 323: test passed 
Iteration 324: test passed 
Iteration 325: test passed 
Iteration 326: test passed 
Iteration 327: test passed 
Iteration 328: test passed 
Iteration 329: test passed 
Iteration 330: test passed 
Iteration 331: test passed 
Iteration 332: test passed 
Iteration 333: test passed 
Iteration 334: test passed 
Iteration 335: test passed 
Iteration 336: test passed 
Iteration 337: test passed 
Iteration 338: test passed 
Iteration 339: test passed 
Iteration 340: test passed 
Iteration 341: test passed 
Iteration 342: test passed 
Iteration 343: test passed 
Iteration 344: test passed 
Iteration 345: test passed 
Iteration 346: test passed 
Iteration 347: test passed 
Iteration 348: test passed 
Iteration 349: test passed 
Iteration 350: test passed 
Iteration 351: test passed 
Iteration 352: test passed 
Iteration 353: test passed 
Iteration 354: test passed 
Iteration 355: test passed 
Iteration 356: test passed 
Iteration 357: test passed 
Iteration 358: test passed 
Iteration 359: test passed 
Iteration 360: test passed 
Iteration 361: test passed 
Iteration 362: test passed 
Iteration 363: test passed 
Iteration 364: test passed 
Iteration 365: test passed 
Iteration 366: test passed 
Iteration 367: test passed 
Iteration 368: test passed 
Iteration 369: test passed 
Iteration 370: test passed 
Iteration 371: test passed 
Iteration 372: test passed 
Iteration 373: test passed 
Iteration 374: test passed 
Iteration 375: test passed 
Iteration 376: test passed 
Iteration 377: test passed 
Iteration 378: test passed 
Iteration 379: test passed 
Iteration 380: test passed 
Iteration 381: test passed 
Iteration 382: test passed 
Iteration 383: test passed 
Iteration 384: test passed 
Iteration 385: test passed 
Iteration 386: test passed 
Iteration 387: test passed 
Iteration 388: test passed 
Iteration 389: test passed 
Iteration 390: test passed 
Iteration 391: test passed 
Iteration 392: test passed 
Iteration 393: test passed 
Iteration 394: test passed 
Iteration 395: test passed 
Iteration 396: test passed 
Iteration 397: test passed 
Iteration 398: test passed 
Iteration 399: test passed 
Iteration 400: test passed 
Iteration 401: test passed 
Iteration 402: test passed 
Iteration 403: test passed 
Iteration 404: test passed 
Iteration 405: test passed 
Iteration 406: test passed 
Iteration 407: test passed 
Iteration 408: test passed 
Iteration 409: test passed 
Iteration 410: test passed 
Iteration 411: test passed 
Iteration 412: test passed 
Iteration 413: test passed 
Iteration 414: test passed 
Iteration 415: test passed 
Iteration 416: test passed 
Iteration 417: test passed 
Iteration 418: test passed 
Iteration 419: test passed 
Iteration 420: test passed 
Iteration 421: test passed 
Iteration 422: test passed 
Iteration 423: test passed 
Iteration 424: test passed 
Iteration 425: test passed 
Iteration 426: test passed 
Iteration 427: test passed 
Iteration 428: test passed 
Iteration 429: test passed 
Iteration 430: test passed 
Iteration 431: test passed 
Iteration 432: test passed 
Iteration 433: test passed 
Iteration 434: test passed 
Iteration 435: test passed 
Iteration 436: test passed 
Iteration 437: test passed 
Iteration 438: test passed 
Iteration 439: test passed 
Iteration 440: test passed 
Iteration 441: test passed 
Iteration 442: test passed 
Iteration 443: test passed 
Iteration 444: test passed 
Iteration 445: test passed 
Iteration 446: test passed 
Iteration 447: test passed 
Iteration 448: test passed 
Iteration 449: test passed 
Iteration 450: test passed 
Iteration 451: test passed 
Iteration 452: test passed 
Iteration 453: test passed 
Iteration 454: test passed 
Iteration 455: test passed 
Iteration 456: test passed 
Iteration 457: test passed 
Iteration 458: test passed 
Iteration 459: test passed 
Iteration 460: test passed 
Iteration 461: test passed 
Iteration 462: test passed 
Iteration 463: test passed 
Iteration 464: test passed 
Iteration 465: test passed 
Iteration 466: test passed 
Iteration 467: test passed 
Iteration 468: test passed 
Iteration 469: test passed 
Iteration 470: test passed 
Iteration 471: test passed 
Iteration 472: test passed 
Iteration 473: test passed 
Iteration 474: test passed 
Iteration 475: test passed 
Iteration 476: test passed 
Iteration 477: test passed 
Iteration 478: test passed 
Iteration 479: test passed 
Iteration 480: test passed 
Iteration 481: test passed 
Iteration 482: test passed 
Iteration 483: test passed 
Iteration 484: test passed 
Iteration 485: test passed 
Iteration 486: test passed 
Iteration 487: test passed 
Iteration 488: test passed 
Iteration 489: test passed 
Iteration 490: test passed 
Iteration 491: test passed 
Iteration 492: test passed 
Iteration 493: test passed 
Iteration 494: test passed 
Iteration 495: test passed 
Iteration 496: test passed 
Iteration 497: test passed 
Iteration 498: test passed 
Iteration 499: test passed 
Village card passed all random tests
File 'randomtestcard2.c'
Lines executed:73.81% of 42
Branches executed:100.00% of 12
Taken at least once:58.33% of 12
Calls executed:68.18% of 22
Creating 'randomtestcard2.c.gcov'

        -:    0:Source:randomtestcard2.c
        -:    0:Graph:randomtestcard2.gcno
        -:    0:Data:randomtestcard2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "rngs.h"
        -:    3:#include <stdio.h>
        -:    4:#include <math.h>
        -:    5:#include <stdlib.h>
        -:    6:#include <assert.h>
        -:    7:#include <time.h>
        -:    8:
        -:    9:#define MAX_TESTS 500 
        -:   10:
function main called 1 returned 100% blocks executed 74%
        1:   11:int main() {
        -:   12:    //initialize variables
        1:   13:    int k[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        -:   14:    int players, player, seed, handPosition, bonus;
        -:   15:    struct gameState game;
        1:   16:    int choice1 = 0;
        1:   17:    int choice2 = 0; 
        1:   18:    int choice3 = 0;
        1:   19:    int test_failed = 0;
        1:   20:    int test_status = 1; 	
        1:   21:    srand(time(NULL));
call    0 returned 100%
call    1 returned 100%
        -:   22:
        1:   23:   printf("/*********************** Randomly Testing Village Card **************************/\n");
call    0 returned 100%
        -:   24:    int i; 
      501:   25:    for(i = 0; i < MAX_TESTS; i++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   26:
        -:   27:        //initialize variables randomly
      500:   28:        players = rand() % (MAX_PLAYERS - 2) + 2;
call    0 returned 100%
      500:   29:        seed = rand();
call    0 returned 100%
      500:   30:        bonus = 0;
      500:   31:        handPosition = rand() % 4;
call    0 returned 100%
      500:   32:        player = i % (players);
        -:   33:
      500:   34:        initializeGame(players, k, seed, &game); //initialize game 
call    0 returned 100%
        -:   35:
        -:   36:        //randomly initialize game's state variables
      500:   37:        game.deckCount[player] = rand() % MAX_DECK;   //Pick random deck size out of MAX DECK size
call    0 returned 100%
      500:   38:        game.discardCount[player] = rand() % MAX_DECK;
call    0 returned 100%
      500:   39:        game.handCount[player] = rand() % MAX_HAND;
call    0 returned 100%
        -:   40:        
        -:   41:    	//grab numbers before calling the card
      500:   42:	int handCount1 = numHandCards(&game);
call    0 returned 100%
      500:   43:	int actionCards1 = game.numActions;
        -:   44:
        -:   45:	//check if card effect works on this card
      500:   46:	if(cardEffect(village, choice1, choice2, choice3, &game, 0, 0) == 0){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:   47:	//check if drawn cards has gone up by 1 and one has been discarded
        -:   48:
        -:   49:	//grab numbers after calling card	
      500:   50:	 int handCount2 = numHandCards(&game);
call    0 returned 100%
      500:   51:        int actionCards2 = game.numActions;
        -:   52:
        -:   53:		//check if hand count and number of action points were changed properly	
      500:   54:        	if(handCount2 != (handCount1 + 1 - 1)){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   55:	
    #####:   56:			printf("Error: Handcount should not have changed after playing village card\n");
call    0 never executed
    #####:   57:			printf("Hand count before: %d. Hand count after: %d.\n", handCount1, handCount2); 
call    0 never executed
    #####:   58:                        test_failed++; 	
    #####:   59:			test_status = 0; //set test state to failed
        -:   60:		}
      500:   61:		if(actionCards2 != (actionCards1 + 2)){									
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   62:		 	printf("Error: Number of action points should have increased by 2 after  playing village card\n");
call    0 never executed
    #####:   63:                	printf("Action points before: %d. Action points after: %d.\n", actionCards1, actionCards2); 
call    0 never executed
    #####:   64:			test_failed++;
    #####:   65:			test_status = 0; //set test state to failed
        -:   66:        	}
        -:   67:	}
        -:   68:	else {
    #####:   69:		printf("Error: card could not be played\n"); 
call    0 never executed
        -:   70:	}
        -:   71:
      500:   72:	if(test_status == 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   73:		printf("Iteration %d: test failed\n", i);
call    0 never executed
        -:   74:	}
        -:   75:	else {
      500:   76:		printf("Iteration %d: test passed \n", i); 
call    0 returned 100%
        -:   77:	}
        -:   78: 	
        -:   79:}
        1:   80:	if(test_failed > 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   81:		printf("Village card failed %d random tests\n", test_failed); 
call    0 never executed
        -:   82:	}
        -:   83:	else {
        1:   84:		printf("Village card passed all random tests\n"); 
call    0 returned 100%
        -:   85:	}
        -:   86:
        1:   87:    return 0;
        -:   88:}
Function 'updateCoins'
Lines executed:81.82% of 11
Branches executed:100.00% of 8
Taken at least once:75.00% of 8
No calls

Function 'gainCard'
Lines executed:0.00% of 13
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 1

Function 'discardCard'
Lines executed:92.31% of 13
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls

Function 'cardEffect'
Lines executed:4.67% of 214
Branches executed:12.57% of 183
Taken at least once:1.09% of 183
Calls executed:3.33% of 60

Function 'EmbargoCard'
Lines executed:0.00% of 8
Branches executed:0.00% of 2
Taken at least once:0.00% of 2
Calls executed:0.00% of 1

Function 'GreatHallCard'
Lines executed:0.00% of 5
No branches
Calls executed:0.00% of 2

Function 'VillageCard'
Lines executed:100.00% of 5
No branches
Calls executed:100.00% of 2

Function 'AdventurerCard'
Lines executed:0.00% of 15
Branches executed:0.00% of 12
Taken at least once:0.00% of 12
Calls executed:0.00% of 2

Function 'SmithyCard'
Lines executed:0.00% of 4
Branches executed:0.00% of 2
Taken at least once:0.00% of 2
Calls executed:0.00% of 1

Function 'getCost'
Lines executed:0.00% of 30
Branches executed:0.00% of 28
Taken at least once:0.00% of 28
No calls

Function 'drawCard'
Lines executed:95.45% of 22
Branches executed:100.00% of 6
Taken at least once:83.33% of 6
Calls executed:100.00% of 1

Function 'getWinners'
Lines executed:0.00% of 24
Branches executed:0.00% of 22
Taken at least once:0.00% of 22
Calls executed:0.00% of 2

Function 'scoreFor'
Lines executed:0.00% of 24
Branches executed:0.00% of 42
Taken at least once:0.00% of 42
Calls executed:0.00% of 3

Function 'isGameOver'
Lines executed:0.00% of 10
Branches executed:0.00% of 8
Taken at least once:0.00% of 8
No calls

Function 'endTurn'
Lines executed:0.00% of 20
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 3

Function 'whoseTurn'
Lines executed:100.00% of 2
No branches
No calls

Function 'fullDeckCount'
Lines executed:0.00% of 9
Branches executed:0.00% of 12
Taken at least once:0.00% of 12
No calls

Function 'supplyCount'
Lines executed:0.00% of 2
No branches
No calls

Function 'handCard'
Lines executed:0.00% of 3
No branches
Calls executed:0.00% of 1

Function 'numHandCards'
Lines executed:100.00% of 2
No branches
Calls executed:100.00% of 1

Function 'buyCard'
Lines executed:0.00% of 13
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
Calls executed:0.00% of 4

Function 'playCard'
Lines executed:0.00% of 14
Branches executed:0.00% of 10
Taken at least once:0.00% of 10
Calls executed:0.00% of 3

Function 'shuffle'
Lines executed:93.75% of 16
Branches executed:100.00% of 8
Taken at least once:87.50% of 8
Calls executed:100.00% of 2

Function 'initializeGame'
Lines executed:93.55% of 62
Branches executed:100.00% of 46
Taken at least once:86.96% of 46
Calls executed:100.00% of 5

Function 'kingdomCards'
Lines executed:0.00% of 13
No branches
No calls

Function 'newGame'
Lines executed:0.00% of 3
No branches
No calls

Function 'compare'
Lines executed:83.33% of 6
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
No calls

File 'dominion.c'
Lines executed:24.69% of 563
Branches executed:24.22% of 417
Taken at least once:16.07% of 417
Calls executed:13.83% of 94
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:
        -:    9:
function compare called 19350 returned 100% blocks executed 83%
    19350:   10:int compare(const void* a, const void* b) {
    19350:   11:  if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   12:    return 1;
    19350:   13:  if (*(int*)a < *(int*)b)
branch  0 taken 26% (fallthrough)
branch  1 taken 74%
     4984:   14:    return -1;
    14366:   15:  return 0;
        -:   16:}
        -:   17:
function newGame called 0 returned 0% blocks executed 0%
    #####:   18:struct gameState* newGame() {
    #####:   19:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   20:  return g;
        -:   21:}
        -:   22:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   23:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   24:		  int k8, int k9, int k10) {
    #####:   25:  int* k = malloc(10 * sizeof(int));
    #####:   26:  k[0] = k1;
    #####:   27:  k[1] = k2;
    #####:   28:  k[2] = k3;
    #####:   29:  k[3] = k4;
    #####:   30:  k[4] = k5;
    #####:   31:  k[5] = k6;
    #####:   32:  k[6] = k7;
    #####:   33:  k[7] = k8;
    #####:   34:  k[8] = k9;
    #####:   35:  k[9] = k10;
    #####:   36:  return k;
        -:   37:}
        -:   38:
function initializeGame called 500 returned 100% blocks executed 94%
      500:   39:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   40:		   struct gameState *state) {
        -:   41:
        -:   42:  int i;
        -:   43:  int j;
        -:   44:  int it;			
        -:   45:  //set up random number generator
      500:   46:  SelectStream(1);
call    0 returned 100%
      500:   47:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   48:  
        -:   49:  //check number of players
      500:   50:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   51:    {
    #####:   52:      return -1;
        -:   53:    }
        -:   54:
        -:   55:  //set number of players
      500:   56:  state->numPlayers = numPlayers;
        -:   57:
        -:   58:  //check selected kingdom cards are different
     5500:   59:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:    {
    55000:   61:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   62:        {
    50000:   63:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   64:	    {
    #####:   65:	      return -1;
        -:   66:	    }
        -:   67:        }
        -:   68:    }
        -:   69:
        -:   70:
        -:   71:  //initialize supply
        -:   72:  ///////////////////////////////
        -:   73:
        -:   74:  //set number of Curse cards
      500:   75:  if (numPlayers == 2)
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
        -:   76:    {
      254:   77:      state->supplyCount[curse] = 10;
        -:   78:    }
      246:   79:  else if (numPlayers == 3)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   80:    {
      246:   81:      state->supplyCount[curse] = 20;
        -:   82:    }
        -:   83:  else
        -:   84:    {
    #####:   85:      state->supplyCount[curse] = 30;
        -:   86:    }
        -:   87:
        -:   88:  //set number of Victory cards
      500:   89:  if (numPlayers == 2)
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
        -:   90:    {
      254:   91:      state->supplyCount[estate] = 8;
      254:   92:      state->supplyCount[duchy] = 8;
      254:   93:      state->supplyCount[province] = 8;
        -:   94:    }
        -:   95:  else
        -:   96:    {
      246:   97:      state->supplyCount[estate] = 12;
      246:   98:      state->supplyCount[duchy] = 12;
      246:   99:      state->supplyCount[province] = 12;
        -:  100:    }
        -:  101:
        -:  102:  //set number of Treasure cards
      500:  103:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      500:  104:  state->supplyCount[silver] = 40;
      500:  105:  state->supplyCount[gold] = 30;
        -:  106:
        -:  107:  //set number of Kingdom cards
    10500:  108:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  109:    {
   105000:  110:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -:  111:	{
    97000:  112:	  if (kingdomCards[j] == i)
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        -:  113:	    {
        -:  114:	      //check if card is a 'Victory' Kingdom card
     2000:  115:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 25% (fallthrough)
branch  3 taken 75%
        -:  116:		{
     1000:  117:		  if (numPlayers == 2){ 
branch  0 taken 51% (fallthrough)
branch  1 taken 49%
      254:  118:		    state->supplyCount[i] = 8; 
        -:  119:		  }
      246:  120:		  else{ state->supplyCount[i] = 12; }
        -:  121:		}
        -:  122:	      else
        -:  123:		{
     1500:  124:		  state->supplyCount[i] = 10;
        -:  125:		}
     2000:  126:	      break;
        -:  127:	    }
        -:  128:	  else    //card is not in the set choosen for the game
        -:  129:	    {
    95000:  130:	      state->supplyCount[i] = -1;
        -:  131:	    }
        -:  132:	}
        -:  133:
        -:  134:    }
        -:  135:
        -:  136:  ////////////////////////
        -:  137:  //supply intilization complete
        -:  138:
        -:  139:  //set player decks
     1746:  140:  for (i = 0; i < numPlayers; i++)
branch  0 taken 71%
branch  1 taken 29% (fallthrough)
        -:  141:    {
     1246:  142:      state->deckCount[i] = 0;
     4984:  143:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  144:	{
     3738:  145:	  state->deck[i][j] = estate;
     3738:  146:	  state->deckCount[i]++;
        -:  147:	}
     9968:  148:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  149:	{
     8722:  150:	  state->deck[i][j] = copper;
     8722:  151:	  state->deckCount[i]++;		
        -:  152:	}
        -:  153:    }
        -:  154:
        -:  155:  //shuffle player decks
     1746:  156:  for (i = 0; i < numPlayers; i++)
branch  0 taken 71%
branch  1 taken 29% (fallthrough)
        -:  157:    {
     1246:  158:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  159:	{
    #####:  160:	  return -1;
        -:  161:	}
        -:  162:    }
        -:  163:
        -:  164:  //draw player hands
     1746:  165:  for (i = 0; i < numPlayers; i++)
branch  0 taken 71%
branch  1 taken 29% (fallthrough)
        -:  166:    {  
        -:  167:      //initialize hand size to zero
     1246:  168:      state->handCount[i] = 0;
     1246:  169:      state->discardCount[i] = 0;
        -:  170:      //draw 5 cards
        -:  171:      // for (j = 0; j < 5; j++)
        -:  172:      //	{
        -:  173:      //	  drawCard(i, state);
        -:  174:      //	}
        -:  175:    }
        -:  176:  
        -:  177:  //set embargo tokens to 0 for all supply piles
    14000:  178:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  179:    {
    13500:  180:      state->embargoTokens[i] = 0;
        -:  181:    }
        -:  182:
        -:  183:  //initialize first player's turn
      500:  184:  state->outpostPlayed = 0;
      500:  185:  state->phase = 0;
      500:  186:  state->numActions = 1;
      500:  187:  state->numBuys = 1;
      500:  188:  state->playedCardCount = 0;
      500:  189:  state->whoseTurn = 0;
      500:  190:  state->handCount[state->whoseTurn] = 0;
        -:  191:  //int it; move to top
        -:  192:
        -:  193:  //Moved draw cards to here, only drawing at the start of a turn
     3000:  194:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
     2500:  195:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  196:  }
        -:  197:
      500:  198:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  199:
      500:  200:  return 0;
        -:  201:}
        -:  202:
function shuffle called 1247 returned 100% blocks executed 94%
     1247:  203:int shuffle(int player, struct gameState *state) {
        -:  204: 
        -:  205:
        -:  206:  int newDeck[MAX_DECK];
     1247:  207:  int newDeckPos = 0;
        -:  208:  int card;
        -:  209:  int i;
        -:  210:
     1247:  211:  if (state->deckCount[player] < 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  212:    return -1;
     1247:  213:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 100%
        -:  214:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  215:
    15138:  216:  while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
    12644:  217:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
    12644:  218:    newDeck[newDeckPos] = state->deck[player][card];
    12644:  219:    newDeckPos++;
    49593:  220:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
    36949:  221:      state->deck[player][i] = state->deck[player][i+1];
        -:  222:    }
    12644:  223:    state->deckCount[player]--;
        -:  224:  }
    13891:  225:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
    12644:  226:    state->deck[player][i] = newDeck[i];
    12644:  227:    state->deckCount[player]++;
        -:  228:  }
        -:  229:
     1247:  230:  return 0;
        -:  231:}
        -:  232:
function playCard called 0 returned 0% blocks executed 0%
    #####:  233:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  234:{	
        -:  235:  int card;
    #####:  236:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  237:
        -:  238:  //check if it is the right phase
    #####:  239:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  240:    {
    #####:  241:      return -1;
        -:  242:    }
        -:  243:	
        -:  244:  //check if player has enough actions
    #####:  245:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  246:    {
    #####:  247:      return -1;
        -:  248:    }
        -:  249:	
        -:  250:  //get card played
    #####:  251:  card = handCard(handPos, state);
call    0 never executed
        -:  252:	
        -:  253:  //check if selected card is an action
    #####:  254:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  255:    {
    #####:  256:      return -1;
        -:  257:    }
        -:  258:	
        -:  259:  //play card
    #####:  260:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  261:    {
    #####:  262:      return -1;
        -:  263:    }
        -:  264:	
        -:  265:  //reduce number of actions
    #####:  266:  state->numActions--;
        -:  267:
        -:  268:  //update coins (Treasure cards may be added with card draws)
    #####:  269:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  270:	
    #####:  271:  return 0;
        -:  272:}
        -:  273:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  274:int buyCard(int supplyPos, struct gameState *state) {
        -:  275:  int who;
        -:  276:  if (DEBUG){
        -:  277:    printf("Entering buyCard...\n");
        -:  278:  }
        -:  279:
        -:  280:  // I don't know what to do about the phase thing.
        -:  281:
    #####:  282:  who = state->whoseTurn;
        -:  283:
    #####:  284:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  285:    if (DEBUG)
        -:  286:      printf("You do not have any buys left\n");
    #####:  287:    return -1;
    #####:  288:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  289:    if (DEBUG)
        -:  290:      printf("There are not any of that type of card left\n");
    #####:  291:    return -1;
    #####:  292:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  293:    if (DEBUG) 
        -:  294:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  295:    return -1;
        -:  296:  } else {
    #####:  297:    state->phase=1;
        -:  298:    //state->supplyCount[supplyPos]--;
    #####:  299:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  300:  
    #####:  301:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  302:    state->numBuys--;
        -:  303:    if (DEBUG)
        -:  304:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  305:  }
        -:  306:
        -:  307:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  308:  //state->discardCount[who]++;
        -:  309:    
    #####:  310:  return 0;
        -:  311:}
        -:  312:
function numHandCards called 1000 returned 100% blocks executed 100%
     1000:  313:int numHandCards(struct gameState *state) {
     1000:  314:  return state->handCount[ whoseTurn(state) ];
call    0 returned 100%
        -:  315:}
        -:  316:
function handCard called 0 returned 0% blocks executed 0%
    #####:  317:int handCard(int handPos, struct gameState *state) {
    #####:  318:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  319:  return state->hand[currentPlayer][handPos];
        -:  320:}
        -:  321:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  322:int supplyCount(int card, struct gameState *state) {
    #####:  323:  return state->supplyCount[card];
        -:  324:}
        -:  325:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  326:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  327:  int i;
    #####:  328:  int count = 0;
        -:  329:
    #####:  330:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  331:    {
    #####:  332:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  333:    }
        -:  334:
    #####:  335:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  336:    {
    #####:  337:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  338:    }
        -:  339:
    #####:  340:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  341:    {
    #####:  342:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  343:    }
        -:  344:
    #####:  345:  return count;
        -:  346:}
        -:  347:
function whoseTurn called 1500 returned 100% blocks executed 100%
     1500:  348:int whoseTurn(struct gameState *state) {
     1500:  349:  return state->whoseTurn;
        -:  350:}
        -:  351:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  352:int endTurn(struct gameState *state) {
        -:  353:  int k;
        -:  354:  int i;
    #####:  355:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  356:  
        -:  357:  //Discard hand
    #####:  358:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  359:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  360:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  361:  }
    #####:  362:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  363:    
        -:  364:  //Code for determining the player
    #####:  365:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  366:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  367:  }
        -:  368:  else{
    #####:  369:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  370:  }
        -:  371:
    #####:  372:  state->outpostPlayed = 0;
    #####:  373:  state->phase = 0;
    #####:  374:  state->numActions = 1;
    #####:  375:  state->coins = 0;
    #####:  376:  state->numBuys = 1;
    #####:  377:  state->playedCardCount = 0;
    #####:  378:  state->handCount[state->whoseTurn] = 0;
        -:  379:
        -:  380:  //int k; move to top
        -:  381:  //Next player draws hand
    #####:  382:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  383:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  384:  }
        -:  385:
        -:  386:  //Update money
    #####:  387:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  388:
    #####:  389:  return 0;
        -:  390:}
        -:  391:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  392:int isGameOver(struct gameState *state) {
        -:  393:  int i;
        -:  394:  int j;
        -:  395:	
        -:  396:  //if stack of Province cards is empty, the game ends
    #####:  397:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  398:    {
    #####:  399:      return 1;
        -:  400:    }
        -:  401:
        -:  402:  //if three supply pile are at 0, the game ends
    #####:  403:  j = 0;
    #####:  404:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  405:    {
    #####:  406:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  407:	{
    #####:  408:	  j++;
        -:  409:	}
        -:  410:    }
    #####:  411:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  412:    {
    #####:  413:      return 1;
        -:  414:    }
        -:  415:
    #####:  416:  return 0;
        -:  417:}
        -:  418:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  419:int scoreFor (int player, struct gameState *state) {
        -:  420:
        -:  421:  int i;
    #####:  422:  int score = 0;
        -:  423:  //score from hand
    #####:  424:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  425:    {
    #####:  426:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  430:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  431:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  432:    }
        -:  433:
        -:  434:  //score from discard
    #####:  435:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  436:    {
    #####:  437:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  441:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  442:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  443:    }
        -:  444:
        -:  445:  //score from deck
    #####:  446:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  447:    {
    #####:  448:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  452:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  453:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  454:    }
        -:  455:
    #####:  456:  return score;
        -:  457:}
        -:  458:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  459:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  460:  int i;	
        -:  461:  int j;
        -:  462:  int highScore;
        -:  463:  int currentPlayer;
        -:  464:
        -:  465:  //get score for each player
    #####:  466:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  467:    {
        -:  468:      //set unused player scores to -9999
    #####:  469:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  470:	{
    #####:  471:	  players[i] = -9999;
        -:  472:	}
        -:  473:      else
        -:  474:	{
    #####:  475:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  476:	}
        -:  477:    }
        -:  478:
        -:  479:  //find highest score
    #####:  480:  j = 0;
    #####:  481:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  482:    {
    #####:  483:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  484:	{
    #####:  485:	  j = i;
        -:  486:	}
        -:  487:    }
    #####:  488:  highScore = players[j];
        -:  489:
        -:  490:  //add 1 to players who had less turns
    #####:  491:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  492:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  493:    {
    #####:  494:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  495:	{
    #####:  496:	  players[i]++;
        -:  497:	}
        -:  498:    }
        -:  499:
        -:  500:  //find new highest score
    #####:  501:  j = 0;
    #####:  502:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  503:    {
    #####:  504:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  505:	{
    #####:  506:	  j = i;
        -:  507:	}
        -:  508:    }
    #####:  509:  highScore = players[j];
        -:  510:
        -:  511:  //set winners in array to 1 and rest to 0
    #####:  512:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  513:    {
    #####:  514:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  515:	{
    #####:  516:	  players[i] = 1;
        -:  517:	}
        -:  518:      else
        -:  519:	{
    #####:  520:	  players[i] = 0;
        -:  521:	}
        -:  522:    }
        -:  523:
    #####:  524:  return 0;
        -:  525:}
        -:  526:
function drawCard called 3000 returned 100% blocks executed 92%
     3000:  527:int drawCard(int player, struct gameState *state)
        -:  528:{	int count;
        -:  529:  int deckCounter;
     3000:  530:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  531:    
        -:  532:    //Step 1 Shuffle the discard pile back into a deck
        -:  533:    int i;
        -:  534:    //Move discard to deck
      185:  535:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
      184:  536:      state->deck[player][i] = state->discard[player][i];
      184:  537:      state->discard[player][i] = -1;
        -:  538:    }
        -:  539:
        1:  540:    state->deckCount[player] = state->discardCount[player];
        1:  541:    state->discardCount[player] = 0;//Reset discard
        -:  542:
        -:  543:    //Shufffle the deck
        1:  544:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  545:   
        -:  546:    if (DEBUG){//Debug statements
        -:  547:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  548:    }
        -:  549:    
        1:  550:    state->discardCount[player] = 0;
        -:  551:
        -:  552:    //Step 2 Draw Card
        1:  553:    count = state->handCount[player];//Get current player's hand count
        -:  554:    
        -:  555:    if (DEBUG){//Debug statements
        -:  556:      printf("Current hand count: %d\n", count);
        -:  557:    }
        -:  558:    
        1:  559:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  560:
        1:  561:    if (deckCounter == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  562:      return -1;
        -:  563:
        1:  564:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
        1:  565:    state->deckCount[player]--;
        1:  566:    state->handCount[player]++;//Increment hand count
        -:  567:  }
        -:  568:
        -:  569:  else{
     2999:  570:    int count = state->handCount[player];//Get current hand count for player
        -:  571:    int deckCounter;
        -:  572:    if (DEBUG){//Debug statements
        -:  573:      printf("Current hand count: %d\n", count);
        -:  574:    }
        -:  575:
     2999:  576:    deckCounter = state->deckCount[player];//Create holder for the deck count
     2999:  577:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     2999:  578:    state->deckCount[player]--;
     2999:  579:    state->handCount[player]++;//Increment hand count
        -:  580:  }
        -:  581:
     3000:  582:  return 0;
        -:  583:}
        -:  584:
function getCost called 0 returned 0% blocks executed 0%
    #####:  585:int getCost(int cardNumber)
        -:  586:{
    #####:  587:  switch( cardNumber ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
        -:  588:    {
        -:  589:    case curse:
    #####:  590:      return 0;
        -:  591:    case estate:
    #####:  592:      return 2;
        -:  593:    case duchy:
    #####:  594:      return 5;
        -:  595:    case province:
    #####:  596:      return 8;
        -:  597:    case copper:
    #####:  598:      return 0;
        -:  599:    case silver:
    #####:  600:      return 3;
        -:  601:    case gold:
    #####:  602:      return 6;
        -:  603:    case adventurer:
    #####:  604:      return 6;
        -:  605:    case council_room:
    #####:  606:      return 5;
        -:  607:    case feast:
    #####:  608:      return 4;
        -:  609:    case gardens:
    #####:  610:      return 4;
        -:  611:    case mine:
    #####:  612:      return 5;
        -:  613:    case remodel:
    #####:  614:      return 4;
        -:  615:    case smithy:
    #####:  616:      return 4;
        -:  617:    case village:
    #####:  618:      return 3;
        -:  619:    case baron:
    #####:  620:      return 4;
        -:  621:    case great_hall:
    #####:  622:      return 3;
        -:  623:    case minion:
    #####:  624:      return 5;
        -:  625:    case steward:
    #####:  626:      return 3;
        -:  627:    case tribute:
    #####:  628:      return 5;
        -:  629:    case ambassador:
    #####:  630:      return 3;
        -:  631:    case cutpurse:
    #####:  632:      return 4;
        -:  633:    case embargo: 
    #####:  634:      return 2;
        -:  635:    case outpost:
    #####:  636:      return 5;
        -:  637:    case salvager:
    #####:  638:      return 4;
        -:  639:    case sea_hag:
    #####:  640:      return 4;
        -:  641:    case treasure_map:
    #####:  642:      return 4;
        -:  643:    }
        -:  644:	
    #####:  645:  return -1;
        -:  646:}
        -:  647:
        -:  648:
function SmithyCard called 0 returned 0% blocks executed 0%
    #####:  649:int SmithyCard(int currentPlayer, struct gameState *state, int handPos) {
        -:  650:
        -:  651:  //+3 Cards
        -:  652:  int i;
    #####:  653:  for (i = 0; i < 5; i++)
branch  0 never executed
branch  1 never executed
        -:  654:  {
    #####:  655:      drawCard(currentPlayer, state);
call    0 never executed
        -:  656:  }
        -:  657:   //discard card from hand
        -:  658:   //discardCard(handPos, currentPlayer, state, 0);
    #####:  659:   return 0;
        -:  660://bug introduced: draw 5 cards instead of 3; do not discard a card
        -:  661:
        -:  662:}
        -:  663:
function AdventurerCard called 0 returned 0% blocks executed 0%
    #####:  664:int AdventurerCard(int currentPlayer, struct gameState *state, int drawntreasure, int temphand[], int cardDrawn, int z) {
        -:  665:
    #####:  666:  while(drawntreasure<5){
branch  0 never executed
branch  1 never executed
    #####:  667:        if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:  668:          shuffle(currentPlayer, state);
call    0 never executed
        -:  669:        }
    #####:  670:        drawCard(currentPlayer, state);
call    0 never executed
    #####:  671:        cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  672:        if (cardDrawn == gold || cardDrawn == silver || cardDrawn == copper)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  673:		drawntreasure++;
        -:  674:        else{
    #####:  675:          temphand[z]=cardDrawn;
    #####:  676:          state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  677:          z++;
        -:  678:        }
        -:  679:      }
    #####:  680:      while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:  681:        state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  682:        z=z-1;
        -:  683:      }
        -:  684:
    #####:  685:  return 0;
        -:  686:// bug introduced: player is able to draw 5 treasure cards instead of 2. 
        -:  687:}
        -:  688:
        -:  689:
function VillageCard called 500 returned 100% blocks executed 100%
      500:  690:int VillageCard(int currentPlayer, struct gameState *state, int handPos){
        -:  691:
        -:  692:   //+1 Card
      500:  693:   drawCard(currentPlayer, state);
call    0 returned 100%
        -:  694:
        -:  695:   //+2 Actions
      500:  696:   state->numActions = state->numActions + 2;
        -:  697:  
        -:  698:    //discard played card from hand
      500:  699:    discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        -:  700:
      500:  701:  return 0; 
        -:  702:// bug introduced: increase action points by 10 instead of 2 and draw 3 cards instead of 1 
        -:  703:}
        -:  704:
function GreatHallCard called 0 returned 0% blocks executed 0%
    #####:  705:int GreatHallCard(int currentPlayer, struct gameState *state, int handPos){
        -:  706:
        -:  707:      //+1 Card
    #####:  708:      drawCard(currentPlayer, state);
call    0 never executed
        -:  709:
        -:  710:      //+1 Actions
    #####:  711:      state->numActions++;
        -:  712:
        -:  713:      //discard card from hand
    #####:  714:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  715:      
    #####:  716:      return 0;   
        -:  717:}
        -:  718:
function EmbargoCard called 0 returned 0% blocks executed 0%
    #####:  719:int EmbargoCard(int currentPlayer, struct gameState *state, int handPos, int choice1) {
        -:  720:
    #####:  721:	state->coins = state->coins + 20;
        -:  722:
        -:  723:      //see if selected pile is in play
    #####:  724:       if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -:  725:          {
    #####:  726:             return -1;
        -:  727:          }
        -:  728:    
        -:  729:       //add embargo token to selected supply pile
    #####:  730:       state->embargoTokens[choice1]++;
    #####:  731:       state->embargoTokens[choice1]++;  
        -:  732:
        -:  733:      //trash card
    #####:  734:       discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
        -:  735:
    #####:  736:	return 0; 
        -:  737://bug introduced: increase state->coins by 20 instead of 2, and add 2 embargo tokens instead of one
        -:  738:}
        -:  739:
function cardEffect called 500 returned 100% blocks executed 3%
      500:  740:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  741:{
        -:  742:  int i;
        -:  743:  int j;
        -:  744:  int k;
        -:  745:  int x;
        -:  746:  int index;
      500:  747:  int currentPlayer = whoseTurn(state);
call    0 returned 100%
      500:  748:  int nextPlayer = currentPlayer + 1;
        -:  749:
      500:  750:  int tributeRevealedCards[2] = {-1, -1};
        -:  751:  int temphand[MAX_HAND];// moved above the if statement
      500:  752:  int drawntreasure=0;
        -:  753:  int cardDrawn;
      500:  754:  int z = 0;// this is the counter for the temp hand
      500:  755:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  756:    nextPlayer = 0;
        -:  757:  }
        -:  758:  
        -:  759:	
        -:  760:  //uses switch to select card and perform actions
      500:  761:  switch( card ) 
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 100%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  762:    {
        -:  763:    case adventurer:
        -:  764:     
        -:  765:	//call function 
    #####:  766:	AdventurerCard(currentPlayer, state, drawntreasure, temphand, cardDrawn, z);
call    0 never executed
        -:  767:
    #####:  768:	return 0;
        -:  769:			
        -:  770:    case council_room:
        -:  771:      //+4 Cards
    #####:  772:      for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  773:	{
    #####:  774:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  775:	}
        -:  776:			
        -:  777:      //+1 Buy
    #####:  778:      state->numBuys++;
        -:  779:			
        -:  780:      //Each other player draws a card
    #####:  781:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  782:	{
    #####:  783:	  if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  784:	    {
    #####:  785:	      drawCard(i, state);
call    0 never executed
        -:  786:	    }
        -:  787:	}
        -:  788:			
        -:  789:      //put played card in played card pile
    #####:  790:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  791:			
    #####:  792:      return 0;
        -:  793:			
        -:  794:    case feast:
        -:  795:      //gain card with cost up to 5
        -:  796:      //Backup hand
    #####:  797:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  798:	temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  799:	state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  800:      }
        -:  801:      //Backup hand
        -:  802:
        -:  803:      //Update Coins for Buy
    #####:  804:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  805:      x = 1;//Condition to loop on
    #####:  806:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  807:	if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  808:	  if (DEBUG)
        -:  809:	    printf("None of that card left, sorry!\n");
        -:  810:
        -:  811:	  if (DEBUG){
        -:  812:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  813:	  }
        -:  814:	}
    #####:  815:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  816:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  817:
        -:  818:	  if (DEBUG){
        -:  819:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  820:	  }
        -:  821:	}
        -:  822:	else{
        -:  823:
        -:  824:	  if (DEBUG){
        -:  825:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  826:	  }
        -:  827:
    #####:  828:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  829:	  x = 0;//No more buying cards
        -:  830:
        -:  831:	  if (DEBUG){
        -:  832:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  833:	  }
        -:  834:
        -:  835:	}
        -:  836:      }     
        -:  837:
        -:  838:      //Reset Hand
    #####:  839:      for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  840:	state->hand[currentPlayer][i] = temphand[i];
    #####:  841:	temphand[i] = -1;
        -:  842:      }
        -:  843:      //Reset Hand
        -:  844:      			
    #####:  845:      return 0;
        -:  846:			
        -:  847:    case gardens:
    #####:  848:      return -1;
        -:  849:			
        -:  850:    case mine:
    #####:  851:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  852:
    #####:  853:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  854:	{
    #####:  855:	  return -1;
        -:  856:	}
        -:  857:		
    #####:  858:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  859:	{
    #####:  860:	  return -1;
        -:  861:	}
        -:  862:
    #####:  863:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  864:	{
    #####:  865:	  return -1;
        -:  866:	}
        -:  867:
    #####:  868:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  869:
        -:  870:      //discard card from hand
    #####:  871:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  872:
        -:  873:      //discard trashed card
    #####:  874:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  875:	{
    #####:  876:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  877:	    {
    #####:  878:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  879:	      break;
        -:  880:	    }
        -:  881:	}
        -:  882:			
    #####:  883:      return 0;
        -:  884:			
        -:  885:    case remodel:
    #####:  886:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  887:
    #####:  888:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  889:	{
    #####:  890:	  return -1;
        -:  891:	}
        -:  892:
    #####:  893:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  894:
        -:  895:      //discard card from hand
    #####:  896:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  897:
        -:  898:      //discard trashed card
    #####:  899:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  900:	{
    #####:  901:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  902:	    {
    #####:  903:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  904:	      break;
        -:  905:	    }
        -:  906:	}
        -:  907:
        -:  908:
    #####:  909:      return 0;
        -:  910:		
        -:  911:    case smithy:
    #####:  912:      	SmithyCard(currentPlayer, state, handPos);
call    0 never executed
    #####:  913:	return 0;
        -:  914:		
        -:  915:    case village:
        -:  916:      
      500:  917:	VillageCard(currentPlayer, state, handPos);
call    0 returned 100%
        -:  918:
      500:  919:	return 0;
        -:  920:		
        -:  921:    case baron:
    #####:  922:      state->numBuys++;//Increase buys by 1!
    #####:  923:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  924:	int p = 0;//Iterator for hand!
    #####:  925:	int card_not_discarded = 1;//Flag for discard set!
    #####:  926:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  927:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  928:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  929:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  930:	    state->discardCount[currentPlayer]++;
    #####:  931:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  932:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  933:	    }
    #####:  934:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  935:	    state->handCount[currentPlayer]--;
    #####:  936:	    card_not_discarded = 0;//Exit the loop
        -:  937:	  }
    #####:  938:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  939:	    if(DEBUG) {
        -:  940:	      printf("No estate cards in your hand, invalid choice\n");
        -:  941:	      printf("Must gain an estate if there are any\n");
        -:  942:	    }
    #####:  943:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  944:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  945:	      state->supplyCount[estate]--;//Decrement estates
    #####:  946:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  947:		isGameOver(state);
call    0 never executed
        -:  948:	      }
        -:  949:	    }
    #####:  950:	    card_not_discarded = 0;//Exit the loop
        -:  951:	  }
        -:  952:			    
        -:  953:	  else{
    #####:  954:	    p++;//Next card
        -:  955:	  }
        -:  956:	}
        -:  957:      }
        -:  958:			    
        -:  959:      else{
    #####:  960:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  961:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  962:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  963:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  964:	    isGameOver(state);
call    0 never executed
        -:  965:	  }
        -:  966:	}
        -:  967:      }
        -:  968:	    
        -:  969:      
    #####:  970:      return 0;
        -:  971:		
        -:  972:    case great_hall:
        -:  973:      
    #####:  974:	GreatHallCard(currentPlayer, state, handPos);
call    0 never executed
        -:  975:
    #####:  976:	return 0;
        -:  977:		
        -:  978:    case minion:
        -:  979:      //+1 action
    #####:  980:      state->numActions++;
        -:  981:			
        -:  982:      //discard card from hand
    #####:  983:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  984:			
    #####:  985:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  986:	{
    #####:  987:	  state->coins = state->coins + 2;
        -:  988:	}
        -:  989:			
    #####:  990:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  991:	{
        -:  992:	  //discard hand
    #####:  993:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  994:	    {
    #####:  995:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  996:	    }
        -:  997:				
        -:  998:	  //draw 4
    #####:  999:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1000:	    {
    #####: 1001:	      drawCard(currentPlayer, state);
call    0 never executed
        -: 1002:	    }
        -: 1003:				
        -: 1004:	  //other players discard hand and redraw if hand size > 4
    #####: 1005:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1006:	    {
    #####: 1007:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1008:		{
    #####: 1009:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1010:		    {
        -: 1011:		      //discard hand
    #####: 1012:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1013:			{
    #####: 1014:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1015:			}
        -: 1016:							
        -: 1017:		      //draw 4
    #####: 1018:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1019:			{
    #####: 1020:			  drawCard(i, state);
call    0 never executed
        -: 1021:			}
        -: 1022:		    }
        -: 1023:		}
        -: 1024:	    }
        -: 1025:				
        -: 1026:	}
    #####: 1027:      return 0;
        -: 1028:		
        -: 1029:    case steward:
    #####: 1030:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1031:	{
        -: 1032:	  //+2 cards
    #####: 1033:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1034:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1035:	}
    #####: 1036:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1037:	{
        -: 1038:	  //+2 coins
    #####: 1039:	  state->coins = state->coins + 2;
        -: 1040:	}
        -: 1041:      else
        -: 1042:	{
        -: 1043:	  //trash 2 cards in hand
    #####: 1044:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1045:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1046:	}
        -: 1047:			
        -: 1048:      //discard card from hand
    #####: 1049:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1050:      return 0;
        -: 1051:		
        -: 1052:    case tribute:
    #####: 1053:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1054:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1055:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1056:	  state->deckCount[nextPlayer]--;
        -: 1057:	}
    #####: 1058:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1059:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1060:	  state->discardCount[nextPlayer]--;
        -: 1061:	}
        -: 1062:	else{
        -: 1063:	  //No Card to Reveal
        -: 1064:	  if (DEBUG){
        -: 1065:	    printf("No cards to reveal\n");
        -: 1066:	  }
        -: 1067:	}
        -: 1068:      }
        -: 1069:	    
        -: 1070:      else{
    #####: 1071:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1072:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1073:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1074:	    state->deckCount[nextPlayer]++;
    #####: 1075:	    state->discard[nextPlayer][i] = -1;
    #####: 1076:	    state->discardCount[nextPlayer]--;
        -: 1077:	  }
        -: 1078:			    
    #####: 1079:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1080:	} 
    #####: 1081:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1082:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1083:	state->deckCount[nextPlayer]--;
    #####: 1084:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1085:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:	state->deckCount[nextPlayer]--;
        -: 1087:      }    
        -: 1088:		       
    #####: 1089:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1090:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1091:	state->playedCardCount++;
    #####: 1092:	tributeRevealedCards[1] = -1;
        -: 1093:      }
        -: 1094:
    #####: 1095:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1096:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1097:	  state->coins += 2;
        -: 1098:	}
        -: 1099:		    
    #####: 1100:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1101:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1102:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1103:	}
        -: 1104:	else{//Action Card
    #####: 1105:	  state->numActions = state->numActions + 2;
        -: 1106:	}
        -: 1107:      }
        -: 1108:	    
    #####: 1109:      return 0;
        -: 1110:		
        -: 1111:    case ambassador:
    #####: 1112:      j = 0;		//used to check if player has enough cards to discard
        -: 1113:
    #####: 1114:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1115:	{
    #####: 1116:	  return -1;				
        -: 1117:	}
        -: 1118:
    #####: 1119:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1120:	{
    #####: 1121:	  return -1;
        -: 1122:	}
        -: 1123:
    #####: 1124:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1125:	{
    #####: 1126:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1127:	    {
    #####: 1128:	      j++;
        -: 1129:	    }
        -: 1130:	}
    #####: 1131:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1132:	{
    #####: 1133:	  return -1;				
        -: 1134:	}
        -: 1135:
        -: 1136:      if (DEBUG) 
        -: 1137:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1138:
        -: 1139:      //increase supply count for choosen card by amount being discarded
    #####: 1140:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1141:			
        -: 1142:      //each other player gains a copy of revealed card
    #####: 1143:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1144:	{
    #####: 1145:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1146:	    {
    #####: 1147:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1148:	    }
        -: 1149:	}
        -: 1150:
        -: 1151:      //discard played card from hand
    #####: 1152:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1153:
        -: 1154:      //trash copies of cards returned to supply
    #####: 1155:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1156:	{
    #####: 1157:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1158:	    {
    #####: 1159:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1160:		{
    #####: 1161:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1162:		  break;
        -: 1163:		}
        -: 1164:	    }
        -: 1165:	}			
        -: 1166:
    #####: 1167:      return 0;
        -: 1168:		
        -: 1169:    case cutpurse:
        -: 1170:
    #####: 1171:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1172:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1173:	{
    #####: 1174:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1175:	    {
    #####: 1176:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1177:		{
    #####: 1178:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1179:		    {
    #####: 1180:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1181:		      break;
        -: 1182:		    }
    #####: 1183:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1184:		    {
    #####: 1185:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1186:			{
        -: 1187:			  if (DEBUG)
        -: 1188:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1189:			}	
    #####: 1190:		      break;
        -: 1191:		    }		
        -: 1192:		}
        -: 1193:					
        -: 1194:	    }
        -: 1195:				
        -: 1196:	}				
        -: 1197:
        -: 1198:      //discard played card from hand
    #####: 1199:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1200:
    #####: 1201:      return 0;
        -: 1202:
        -: 1203:		
        -: 1204:    case embargo: 
        -: 1205:      
    #####: 1206:	EmbargoCard(currentPlayer, handPos, state, choice1); 
call    0 never executed
    #####: 1207:	return 0;
        -: 1208:		
        -: 1209:    case outpost:
        -: 1210:      //set outpost flag
    #####: 1211:      state->outpostPlayed++;
        -: 1212:			
        -: 1213:      //discard card
    #####: 1214:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1215:      return 0;
        -: 1216:		
        -: 1217:    case salvager:
        -: 1218:      //+1 buy
    #####: 1219:      state->numBuys++;
        -: 1220:			
    #####: 1221:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1222:	{
        -: 1223:	  //gain coins equal to trashed card
    #####: 1224:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1225:	  //trash card
    #####: 1226:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1227:	}
        -: 1228:			
        -: 1229:      //discard card
    #####: 1230:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1231:      return 0;
        -: 1232:		
        -: 1233:    case sea_hag:
    #####: 1234:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1235:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1236:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1237:	  state->discardCount[i]++;
    #####: 1238:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1239:	}
        -: 1240:      }
    #####: 1241:      return 0;
        -: 1242:		
        -: 1243:    case treasure_map:
        -: 1244:      //search hand for another treasure_map
    #####: 1245:      index = -1;
    #####: 1246:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1247:	{
    #####: 1248:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1249:	    {
    #####: 1250:	      index = i;
    #####: 1251:	      break;
        -: 1252:	    }
        -: 1253:	}
    #####: 1254:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1255:	{
        -: 1256:	  //trash both treasure cards
    #####: 1257:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1258:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1259:
        -: 1260:	  //gain 4 Gold cards
    #####: 1261:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1262:	    {
    #####: 1263:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1264:	    }
        -: 1265:				
        -: 1266:	  //return success
    #####: 1267:	  return 1;
        -: 1268:	}
        -: 1269:			
        -: 1270:      //no second treasure_map found in hand
    #####: 1271:      return -1;
        -: 1272:    }
        -: 1273:	
    #####: 1274:  return -1;
        -: 1275:}
        -: 1276:
function discardCard called 500 returned 100% blocks executed 89%
      500: 1277:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1278:{
        -: 1279:	
        -: 1280:  //if card is not trashed, added to Played pile 
      500: 1281:  if (trashFlag < 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1282:    {
        -: 1283:      //add card to played pile
      500: 1284:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      500: 1285:      state->playedCardCount++;
        -: 1286:    }
        -: 1287:	
        -: 1288:  //set played card to -1
      500: 1289:  state->hand[currentPlayer][handPos] = -1;
        -: 1290:	
        -: 1291:  //remove card from player's hand
      500: 1292:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -: 1293:    {
        -: 1294:      //reduce number of cards in hand
        1: 1295:      state->handCount[currentPlayer]--;
        -: 1296:    }
      499: 1297:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1298:    {
        -: 1299:      //reduce number of cards in hand
    #####: 1300:      state->handCount[currentPlayer]--;
        -: 1301:    }
        -: 1302:  else 	
        -: 1303:    {
        -: 1304:      //replace discarded card with last card in hand
      499: 1305:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1306:      //set last card to -1
      499: 1307:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1308:      //reduce number of cards in hand
      499: 1309:      state->handCount[currentPlayer]--;
        -: 1310:    }
        -: 1311:	
      500: 1312:  return 0;
        -: 1313:}
        -: 1314:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1315:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1316:{
        -: 1317:  //Note: supplyPos is enum of choosen card
        -: 1318:	
        -: 1319:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1320:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1321:    {
    #####: 1322:      return -1;
        -: 1323:    }
        -: 1324:	
        -: 1325:  //added card for [whoseTurn] current player:
        -: 1326:  // toFlag = 0 : add to discard
        -: 1327:  // toFlag = 1 : add to deck
        -: 1328:  // toFlag = 2 : add to hand
        -: 1329:
    #####: 1330:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1331:    {
    #####: 1332:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1333:      state->deckCount[player]++;
        -: 1334:    }
    #####: 1335:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1336:    {
    #####: 1337:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1338:      state->handCount[player]++;
        -: 1339:    }
        -: 1340:  else
        -: 1341:    {
    #####: 1342:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1343:      state->discardCount[player]++;
        -: 1344:    }
        -: 1345:	
        -: 1346:  //decrease number in supply pile
    #####: 1347:  state->supplyCount[supplyPos]--;
        -: 1348:	 
    #####: 1349:  return 0;
        -: 1350:}
        -: 1351:
function updateCoins called 500 returned 100% blocks executed 82%
      500: 1352:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1353:{
        -: 1354:  int i;
        -: 1355:	
        -: 1356:  //reset coin count
      500: 1357:  state->coins = 0;
        -: 1358:
        -: 1359:  //add coins for each Treasure card in player's hand
     3000: 1360:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1361:    {
     2500: 1362:      if (state->hand[player][i] == copper)
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
        -: 1363:	{
     1760: 1364:	  state->coins += 1;
        -: 1365:	}
      740: 1366:      else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1367:	{
    #####: 1368:	  state->coins += 2;
        -: 1369:	}
      740: 1370:      else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1371:	{
    #####: 1372:	  state->coins += 3;
        -: 1373:	}	
        -: 1374:    }	
        -: 1375:
        -: 1376:  //add bonus
      500: 1377:  state->coins += bonus;
        -: 1378:
      500: 1379:  return 0;
        -: 1380:}
        -: 1381:
        -: 1382:
        -: 1383://end of dominion.c
        -: 1384:
